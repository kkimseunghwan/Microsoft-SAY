
# 면접 관련 하이라이트
# 주제 : Call by Value, Call by Reference

# 함수명 같아도 됨 -> 파이썬은 달라야 함.
# 변수명 달라야 함. -> 동일한 공간에서

# Call by Value, Call by Reference
# 파이썬 : Call by Value <- 얘 없음
# 파이썬 : Call by Reference <- 얘만 있음

# 파이썬에서 모든 값은 객체(주소 값, Reference)로 전달됨. => 이게 Call by Reference

# 값을 넣어서 호출이냐, 주소값 넣어서 호출이냐 차이.

# 파이썬은 주소값 넣어서 호출.
'''
파이썬에서 변수는 "값"이 아니라 "객체의 참조(주소)"를 저장함.
메모리는 크게 Stack(스택)과 Heap(힙)으로 나뉨.

Stack 메모리: 함수 실행 시 지역 변수(변수 이름과 참조 주소) 저장
Heap 메모리: 실제 데이터(객체) 저장
'''

# 함수 위쪽에서 정의를 하면, 아래 함수에서 동일한 이름의 변수를 수정하면 기존 값이 변경될까?
# 파이썬 정수 캐싱 : 변수에 저장된 동일한 작은 값이 동일한 주소를 공유하는 현상
d = 10
e = 10
# d, e 변수가 가리키는 주소값이 동일함.

print("red d, e", d, e, id(d), id(e))

################

# test 라는 함수의 공간
def test(a, b, c): 
    # 함수 실행 시, a, b, c 는 새로운 지역변수(green)a, b, c가 됨. (지역변수: 함수 안에서 만들어진 변수)

    # 이 지역변수들은 기존 (red)a, b, c가 가르키는 객체의 주소를 그대로 참조함.

    # (red)a, b, c 와 (green)a, b, c가 가리키는 주소값은 같음.
    print("\n함수 내 재정의 전.")
    print("green", a, id(a)) 
    print("green b", b[0], id(b))
    print("green c", c[0], id(c))

    # heap 메모리에 추가적인 주소 생성, 100 값이 저장. 스택 메모리에 저장된 (green)a는 heap메모리에 새로 정의한 주소를 저장.
    a = 100 # 새로운 정수 값 할당. => 100 값이 저장된 새로운 메모리 주소로 변경됨
    
    b[0] = 100 # 주소가 참조하는 리스트 내부의 값 변경 => 원본 리스트도 변경됨
    # stakc에 새로운 b라는 지역변수가 생겼지만, 동일한 리스트(주소)를 가리키고 있음.
    # b[0] = 100 를 통해 기존 리스트(주소가 가리키는 값)의 첫 번째 요소가를 변경함.
    # 함수 내 (green)b 가 기존 (red)b 리스트를 참조하고 있었기 때문에, 원본도 변경됨!

    c = [100, 200] # 새로운 리스트 생성 => 원본 리스트와 무관해짐으로 [100, 200] 리스트가 저장된 새로운 메모리 주소로 변경됨
    
    d = 123 # 함수 외부의 d 와는 아무런 관련이 없음. 새로운 지역변수(green) d가 생성되는 것. 
    
    global e # 전역 변수 e를 사용하겠다고 선언 (red)e 를 가리킴
    e = 123 # 전역 변수 e의 값을 변경

    print("\n함수 내 재정의 후.")
    print("green a", a, id(a)) # a의 주소값은 변경.
    print("green b", b[0], id(b)) # b의 주소값은 동일
    print("green c", c[0], id(c)) # c의 주소값은 변경.
    print("green d", d, id(d))
    print("green e", e, id(e))

    # 함수가 끝나면 Stack에 있던 지역 변수 b는 사라짐.
    # 하지만 리스트는 heap에 존재하므로 변경되 상태가 유지됨.
    # 따라서 람수 호출 후에도 b의 값이 변경된 상태가 됨.


################

# main 코드가 실행되는 공간
# 함수 밖에서 만들어진 변수 : 전역변수
a = 10
b = [10, 20]
c = [10, 20]

print("red a", a, id(a))
print("red b", b[0], id(b)) 
print("red c", c[0], id(c)) 

# 함수 실행
test(a, b, c)

print("\n함수 실행 후!")

print("red a", a, id(a)) # 여전히 10 (함수 내부 변경과 무관)
print("red b", b[0], id(b)) # 변경됨. 기존 리스트의 주소값을 참조하여 변경함.
print("red c", c[0], id(c)) # 변경되지 않음 (함수 내부의 지역변수 c가 새 리스트를 가리키기 때문)
print("red d", d, id(d))
print("red e", e, id(e))
